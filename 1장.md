### 타입스크립트란, 데이터의 타입을 명시적으로 표시할 수 있게 된 자바스크립트입니다.

---

### 타입이란, 데이터의 형태를 의미합니다.

---

### 타이핑이란, 타입을 부여하는 행위를 뜻합니다.

---

### 변수와 반환값을 스스로 추론할 수 있지만, 매개변수에는 타입을 부여해야 합니다.

---

### 매개변수에 타입을 붙여주지 않아 암묵적 any가 붙으면, 그러한 any로 발생하는 에러를 implicitAny 에러라고 부릅니다.

---

### {} 타입은, null과 undefined를 제외한 모든 타입을 의미합니다.

---

### 타입스크립트가 추론한 타입에 대해 반론을 제시하지 않고, 타입스크립트가 예상과는 달리 잘못 추론했을 경우에만 올바른 타입을 표기합니다.

---

### let과 const 변수의 타입 추론은 각각 다릅니다.

---

### 객체를 표시하는 리터럴 타입도 존재합니다.

---

### 값이 변하지 않는 것이 확실하다면(객체의), as const라는 특별한 접미사를 붙이면 됩니다.

---

### 빈 배열은 any[]로 추론되므로 조심해야 합니다.

---

### 각 요소 자리에 타입이 고정되어 있는 배열을, 튜플이라고 부릅니다. 튜플은 다음과 같이 타이핑합니다.
```typescript
const tuple: [number, boolean, string] = [1, false, 'hi'];
tuple[0] = 3;
tuple[2] = 5; // Type 'number' is not assignable to type 'string'.
tuple[3] = 'no' // Type '"no"' is not assignable to type 'undefined'.
tuple.push('yes');

// push 사용 막으려면 이렇게
const tupleReadOnly: readonly [number, boolean, string] = . . .;
```

### 이렇듯이, 배열보다 더 정교한 타입 검사를 원한다면 튜플을 사용합니다. 

### 튜플은 길이가 고정되어 있지는 않습니다.

---

### 옵셔널 수식어인 ?은, 주로 튜플이나 매개변수에 사용되며 값의 할당이 선택적이라는 의미입니다. 옵셔널 자리에는 undefined가 들어갈 수 있습니다.

---

### 변수 이름은 타입으로 사용할 수 없으나, 내장 객체는 타입으로 사용할 수 있습니다.

---

### Number, Object, String, Boolean, Symbol이 아닌 number, object, string, boolean, symbol을 사용하세요.

---

### 타입으로 사용할 수 없는 값을 타입으로 사용하려면, 값 앞에 typeof를 붙이면 알맞게 추론해줍니다.

---

### 함수의 호출은 타입에 사용할 수 없습니다.

---

### 클래스는 typeof 없이도 타입으로 사용할 수 있습니다.

---

### 타입스크립트에서는 |를 파이프 연산자라고 부릅니다.

---

### 유니언 타입은, 하나의 변수가 여러 타입을 가질 수 있는 가능성을 표시하는 것입니다.

---

### 타입스크립트는 if문을 인식하기에, 타입 좁히기 기법을 사용할 수 있습니다.

---

### any 타입은 타입 검사를 포기한다는 선언과 같으니, 이를 최대한 피해야 합니다.
```typescript
fetch('url').then<{ data: string }>((response) => {
    return response.json();
}).then((result) => {. . .});

const result: { hello: string } = JSON.parse('{"hello":"json"}');
```

---

### unknown은 any와 비슷하게 모든 타입을 대입할 수 있지만, 그 후 어떠한 동작도 수행할 수 없습니다.
```typescript
const a: unknown = 'hello';
const b: unknown = 'world';
a + b; // 'b' is of type 'unknown'.
a.slice(); // 'a' is of type 'unknown'.
```

### try catch 문의 catch에서 unknown을 보게 됩니다.

---

### 제네릭은 리액트의 JSX와 충돌하므로 as로 주장하는 것을 권장합니다.

---

### !(non-null assertion) 연산자는 null 또는 undefined가 아님을 주장하는 연산자입니다. 개발자가 보장하는 것이기에 책임을 져야 합니다.

---

### 타입스크립트에서는 반환값이 없는 경우, void 타입으로 추론합니다. 반환값을 무시하기 위함입니다.

---

### 반환값 자체를 void로 설정하면, 값을 무시할 뿐이지 에러를 발생하지는 않습니다.
```typescript
[1, 2, 3].forEach((v) => v.toString()); // v.toString()의 반환값 무시
```

### 즉, void는 
1. 사용자가 함수의 반환값을 사용하지 못하도록 제한하고,
2. 반환값을 사용하지 않는 콜백 함수를 타이핑할 때 사용합니다.

---

### {}은 실제로 유형으로 쓰는 경우가 별로 없지만, 이는 조건문에서 unknown 타입을 걸러낼 때 보여지는 것입니다.

---

### 함수 선언문일 때는 throw를 했을 때 void를 반환하고, 함수 표현식은 never를 반환합니다. 이 때 선언문에서 never를 반환하고자 하면 반환 타입에 never를 써주어야 합니다.

---

```typescript
type A = string;
const str: A = 'hello';
```

### 기존 타입에 새로운 이름을 붙여주는것을 '타입 별칭'이라고 부릅니다. 타입 별칭은 대문자로 시작합니다. 타입 표기가 길어질 경우 사용하는 게 주 사용 방법입니다.

---

### 객체 타입에 이름을 붙이는 class를 제외한 또 하나의 방법으로 인터페이스 선언이 있습니다. 이도 대문자로 시작합니다.

```typescript
interface Person {
    name: string,
    age: number,
    married: boolean
}
```

### 인터페이스는 합칠 수 있지만, 인터페이스 간에 속성이 겹치는데 타입이 다를 경우에는 에러가 발생합니다.

---

### 우연의 일치로 인터페이스의 이름이 겹치는 경우를 방지하기 위해 사용하는 게 네임스페이스입니다.

```typescript
namespace Example {
    export interface Inner { test: string; }
    export type test2 = number;
}

const ex1: Example.Inner = { test: 'hello', };
```

### 네임스페이스는 중첩하여 사용해도 됩니다. 대신 내부의 네임스페이스도 export 해야 합니다.

### 그런데, 네임스페이스도 중복될 수 있기에 이를 확실하게 방지하려면 모듈 파일을 사용해야 합니다.

---

### 인덱스 시그니처는 선언할 모든 속성 뒤에 존재해야 하며, 이는 그러한 속성들 뒤에 오는 것들이 인덱스 시그니처로 설정한 속성의 타입으로만 들어올 수 있다는 것입니다.

---

### 객체의 속성에도, 옵셔널이나 readonly 수식어가 가능합니다.

```typescript
interface Example {
    hello: string,
    world?: number;
    readonly wow: boolean;
    readonly multiple?: symbol;
}
```

---

### 인터페이스를 타입으로 넣은 변수에 객체 리터럴을 대입했냐, 변수를 대입했냐에 따라 타입 검사 방식이 달라집니다.

---

### 속성의 타입을 따로 type 변수로 빼서 확인하고 싶다면, 이렇게 하면 됩니다 :
```typescript
type Animal = { name: string; }

type N1 = Animal['name'];
type N2 = Animal["name"];
```

---

### 매핑된 객체 타입이란, 이런 것입니다. : 

```typescript
type HelloAndHi = {
    [key in 'hello' | 'hi']: string;
};
```

### in 연산자를 사용해서, 인덱스 시그니처가 표현하지 못하는 타입을 표현합니다. in 오른쪽에는 유니언 타입이 와야 하고, 인터페이스에서는 쓰지 못하며 타입 별칭에서만 사용할 수 있습니다.

---

### 인터섹션 연산자란, 교집합을 나타내는 연산자입니다. &

### any 타입은 집합 관계를 무시하므로 사용해서는 안됩니다.

---

