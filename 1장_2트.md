### 타입스크립트에서는, 객체나 유사 배열 객체 내부의 값도 변하지 않는다면, as const를 붙여 변치 않음을 보장해줍니다.
```typescript
const obj = { name: 'zero' } as const;
const arr = [1, 3, 'five'] as const;
```

### 위 코드로 as const를 붙인 모습을 볼 수 있으며, 이를 사용하면 실수로 객체를 변경하여 에러가 발생하는 일을 줄일 수 있습니다.

---

### 타이핑이란, 어떤 것에 대해서 타입을 정의하는 행위를 말합니다.

---

### 배열 타이핑을 간단하게 표기하는 방법이 있습니다.
```typescript
const arr1: string[] = ['1', '2', '3'];
const arr2: Array<number> = [1, 2, 3];
const arr3: readonly string[] = ['4', '5', '6'];
arr1.push(4); // 4의 타입이 number라서 파라미터가 string인 배열에 이를 넣을 수 없다는 오류가 발생합니다.
```

### 타입스크립트는 배열을 추론할 때, 요소들의 타입을 토대로 추론하는데, 이 때 빈 배열이라면 any[]가 되므로 주의해야 합니다.

### 이 때 문제는, arr1 배열이 string으로 확정되었기 때문에 없는 인덱스에 접근해도 string이 들어있다고 컴파일러가 확신해버립니다. 그래서 아래의 코드가 가능해집니다.
```typescript
arr1[3].string전문메서드();
```

### 위 코드를 해결할 수 있는 방법은, '각 요소 자리에 타입이 고정되어 있는 배열을 일컫는' 튜플을 사용합니다. 다음과 같이 사용합니다. :
```typescript
const tuple: [number, boolean, string] = [1, false, 'hi'];
tuple[0] = 3;
tuple[2] = 5; // number 타입은 string 타입에 할당 불가능합니다.
tuple[3] = 'no'; // "no" 타입은 undefined 타입에 할당 불가능합니다, 그리고 tuple 배열의 길이는 3이므로 인덱스 3에는 요소가 없습니다.
```

### 이미 0,1,2를 제외한 인덱스에는 접근이 불가하지만, 배열 메서드인 push 등의 메서드는 사용은 가능합니다. 그러나 이 메서드 사용까지 막고 싶다면 이렇게 타입의 앞에 readonly를 붙여줍니다. :
```typescript
const tuple: readonly [number, boolean, string] = [1, false, 'hi'];
. . .
```

### 따라서 문제가 발생했던 코드를 이렇게 해결할 수 있습니다. :
```typescript
const arr1: [string, string, string] = ['1', '2', '3'];
arr1[3].string전문메서드(); // 객체는 아무리 조작해도 undefined입니다.
```

### 이렇게, 배열보다 정교한 타입 검사를 원한다면 튜플을 사용하면 됩니다.

---

### 튜플이 '길이가 고정된 배열'이 아닌 '각 요소 자리에 타입이 고정되어 있는 배열'인 이유 : 전개 문법
```typescript
const strNumBools: [string, number, ...boolean[]] = ['hi', 123, false, true, false];

const arr1 = ['hi', true];
const arr = [46, ...arr1];
```

---

### 배열 구조 분해 할당에서도 전개 문법을 사용할 수 있습니다.
```typescript
const [a, ...rest2]: [string, ...number[]] = ['hi', 1, 23, 456];
```

---

### 옵셔널 수식어를 사용하여 해당 자리에 값의 필수 여부를 따질 수 있습니다.
```typescript
let tuple: [number, boolean?, string?] = [1, false, 'hi'];
tuple = [3, true];
tuple = [5];
tuple = [7, 'no']; // boolean | undefined 가 와야 하나 string이 와서 할당 불가능.
```

---

### 타입은 값으로 사용할 수 없습니다. 그런데 값은 타입으로 사용 가능하기에, 타입으로 사용 가능한 값과 가능하지 않은 값을 구분해야 합니다.

---

### String, Object, Number, Boolean, Symbol을 사용하지 말고, string, object, number, boolean, symbol을 사용해야 합니다.

---

### 함수도 typeof 연산자를 붙이면 타이핑이 가능합니다. 클래스는 typeof 없이도 가능합니다.
```typescript
function add(x: number, y:number) { return x + y; }
const add2: typeof add = (x: number, y: number) => x + y;
```

---

### 유니언 타입으로부터 정확한 타입을 찾아내야(타입 좁히기) 그 타입의 목적에 맞는 메서드를 사용할 수 있습니다.
```typescript
let strOrNum: string | number = 'hello';
strOrNum = 123;

if (typeof strOrNum === 'number') {
    strOrNum.toFixed();
}
```

### 여러 줄에 걸쳐서 유니언을 표기하고 싶을 때 :
```typescript
type Union2 =
    | string
    | boolean
    | number
    | null;
```

---

### unknown은 any와 비슷하게 모든 타입을 대입할 수 있지만, 그 후 unknown 타입의 변수는 어떠한 동작도 수행할 수 없게 됩니다.

### unknown은 주로 try - catch 문에서 자주 발견됩니다.

---

### Type Assertion(타입 단언) 방법들
1. as 연산자 사용
2. 제네릭 사용, 나중에 배울 React의 JSX와 충돌하므로 되도록 자제
3. !(non-null assertion) 연산자 사용, null 또는 undefined가 아님을 주장하는 연산자

- param이 null 또는 undefined가 아님이 확실한 경우
```typescript
function a(param: string | null | undefined) {
    param!.slice(3);
}
```

---

### void는 JS에서와는 달리 TS에서는 타입으로 사용합니다.